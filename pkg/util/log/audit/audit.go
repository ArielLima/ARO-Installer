package audit

// Copyright (c) Microsoft Corporation.
// Licensed under the Apache License 2.0.

import (
	"encoding/json"
	"os"
	"runtime"
	"sync"
	"time"

	uuid "github.com/satori/go.uuid"
	"github.com/sirupsen/logrus"

	"github.com/Azure/ARO-RP/pkg/env"
	"github.com/Azure/go-autorest/autorest/to"
)

const (
	MetadataCreatedTime = "createdTime"
	MetadataPayload     = "payload"
	MetadataLogKind     = "logKind"
	MetadataSource      = "source"

	SourceAdminPortal = "aro-admin"
	SourceRP          = "aro-rp"

	EnvelopeKeyCloudRole     = "envCloudRole"
	EnvelopeKeyCorrelationID = "envCorrelationID"

	PayloadKeyCallerIdentities = "payloadCallerIdentities"
	PayloadKeyCategory         = "payloadCategory"
	PayloadKeyNCloud           = "payloadNCloud"
	PayloadKeyOperationName    = "payloadOperationName"
	PayloadKeyResult           = "payloadResult"
	PayloadKeyRequestID        = "payloadRequestID"
	PayloadKeyTargetResources  = "payloadTargetResources"

	ifxAuditCloudVer = 1.0
	ifxAuditLogKind  = "ifxaudit"
	ifxAuditName     = "#Ifx.AuditSchema"
	ifxAuditVersion  = 2.1

	// ifxAuditFlags is a collection of values bit-packed into a 64-bit integer.
	// These properties describe how the event should be processed by the pipeline
	// in an implementation-independent way.
	ifxAuditFlags = 257

	// ifxAuditPopSample is the effective percentage sample rate for this event at the
	// time it was generated by a client (either the default value specified in
	// the event definition, system default or a dynamic override from a cloud
	// settings service).
	// not used by Azure
	ifxAuditPopSample = 0.0
)

var (
	// epoch is an unique identifier associated with the current session of the
	// telemetry library running on the platform. It must be stable during a
	// session, and has no implied ordering across sessions.
	epoch = uuid.NewV4().String()

	// seqNum is used to track absolute order of uploaded events, per session.
	// It is reset when the ARO component is restarted. The first log will have
	// its sequence number set to 1.
	seqNum      uint64
	seqNumMutex sync.Mutex
)

// NewEntry returns a log entry that embeds the provided logger. It has a hook
// that knows how to hydrate an IFxAudit-compliant payload before logging it.
func NewEntry(env env.Core, logger *logrus.Logger) *logrus.Entry {
	logger.AddHook(&payloadHook{
		payload: &AuditPayload{},
		env:     env,
	})

	return logrus.NewEntry(logger)
}

// payloadHook, when fires, hydrates an audit payload using data in a log
// entry.
type payloadHook struct {
	payload *AuditPayload
	env     env.Core
}

func (payloadHook) Levels() []logrus.Level {
	return logrus.AllLevels
}

func (h *payloadHook) Fire(entry *logrus.Entry) error {
	hostname, err := os.Hostname()
	if err != nil {
		return err
	}

	payload := *h.payload // shallow copy

	// Part-A
	payload.EnvOS = to.StringPtr(runtime.GOOS)
	payload.EnvVer = ifxAuditVersion
	payload.EnvName = to.StringPtr(ifxAuditName)
	payload.EnvEpoch = &epoch
	payload.EnvPopSample = ifxAuditPopSample
	payload.EnvFlags = ifxAuditFlags
	payload.EnvCloudVer = ifxAuditCloudVer
	payload.EnvCloudName = to.StringPtr(h.env.Environment().Name)
	payload.EnvCloudRoleInstance = &hostname
	payload.EnvCloudLocation = to.StringPtr(h.env.Location())
	payload.EnvSeqNum = nextSeqNum()

	logTime := entry.Time.UTC().Format(time.RFC3339)
	payload.EnvTime = to.StringPtr(logTime)

	if v, ok := entry.Data[EnvelopeKeyCloudRole].(string); ok {
		payload.EnvCloudRole = &v
		delete(entry.Data, EnvelopeKeyCloudRole)
	}

	if v, ok := entry.Data[EnvelopeKeyCorrelationID].(string); ok {
		payload.EnvCV = &v
		delete(entry.Data, EnvelopeKeyCorrelationID)
	}

	// Part-B
	if v, ok := entry.Data[PayloadKeyCategory].(Category); ok {
		payload.Category = v
		delete(entry.Data, PayloadKeyCategory)
	}

	if v, ok := entry.Data[PayloadKeyNCloud].(string); ok {
		payload.NCloud = &v
		delete(entry.Data, PayloadKeyNCloud)
	}

	if v, ok := entry.Data[PayloadKeyOperationName].(string); ok {
		payload.OperationName = &v
		delete(entry.Data, PayloadKeyOperationName)
	}

	if v, ok := entry.Data[PayloadKeyRequestID].(string); ok {
		payload.RequestID = &v
		delete(entry.Data, PayloadKeyRequestID)
	}

	if v, ok := entry.Data[PayloadKeyResult].(Result); ok {
		payload.Result = v
		delete(entry.Data, PayloadKeyResult)
	}

	if ids, ok := entry.Data[PayloadKeyCallerIdentities].([]*CallerIdentity); ok {
		for _, id := range ids {
			payload.CallerIdentities = append(payload.CallerIdentities, id)
		}
		delete(entry.Data, PayloadKeyCallerIdentities)
	}

	if rs, ok := entry.Data[PayloadKeyTargetResources].([]*TargetResource); ok {
		for _, r := range rs {
			payload.TargetResources = append(payload.TargetResources, r)
		}
		delete(entry.Data, PayloadKeyTargetResources)
	}

	// add the audit payload
	b, err := json.Marshal(payload)
	if err != nil {
		return err
	}
	entry.Data[MetadataPayload] = string(b)

	// add non-IFxAudit metadata for our own use
	entry.Data[MetadataCreatedTime] = logTime
	entry.Data[MetadataLogKind] = ifxAuditLogKind

	return nil
}

func nextSeqNum() uint64 {
	seqNumMutex.Lock()
	defer seqNumMutex.Unlock()

	seqNum++
	return seqNum
}
